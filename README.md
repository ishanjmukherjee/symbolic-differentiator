# Symbolic differentiator

![CI](https://github.com/ishanjmukherjee/symbolic-differentiator/actions/workflows/ci.yml/badge.svg)


A Python library for symbolic differentiation of mathematical expressions. This
library takes
[Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language))-style
mathematical expressions and computes their derivatives with respect to a given
variable.

## Features

- Supports `+` and `*` with multiple operands.
- Supports `-`, `/` and `^` with two operands.
- Error handling and input validation.
- Property-based testing of invariants using [Hypothesis](https://hypothesis.readthedocs.io/en/latest/).

## Installation

1. Clone the repository:

```bash
git clone https://github.com/ishanjmukherjee/symbolic-differentiator.git
cd symbolic-differentiator
```

2. Install using `pip`:

```bash
pip install -e .
```

## Usage

The library uses Lisp-style symbolic expressions (s-expressions) for
mathematical formulas. The main difference is that we use [prefix](https://en.wikipedia.org/wiki/Polish_notation) instead of
the more common [infix](https://en.wikipedia.org/wiki/Infix_notation) operator notation. Here's how to represent some common expressions:

- `x + 2` → `(+ x 2)`
- `x * y` → `(* x y)`
- `(x + 1) * (y - 2)` → `(* (+ x 1) (- y 2))`
- `x^2` → `(^ x 2)`
- `(x + 1)/(y - 1)` → `(/ (+ x 1) (- y 1))`

The main advantage of this format is that it makes operator precedence unambiguous.

The main function `differentiate()` takes an expression string and a variable name
(defaults to "`x`") and returns the derivative as a simplified s-expression
string.

## Error handling

- Invalid syntax: Mismatched parentheses, invalid operators
- Invalid variable names: Empty strings, whitespace, invalid characters
- Mathematical errors: Division by zero, invalid exponents
- Unsupported operations: undefined operators (like trig and log for now)

## Examples

A more extensive demonstration of usage is in `demo.py`.

```python
from symbolic_diff import differentiate

# Basic examples
print(differentiate("x"))        # "1"
print(differentiate("(+ x 5)"))  # "1"
print(differentiate("(* x x)"))  # "(+ x x)"
print(differentiate("(^ x 2)"))  # "(* 2 x)"

# More complex examples
print(differentiate("(* (+ x 1) (- x 2))"))         # (+ (+ x -2) (+ x 1))
print(differentiate("(+ (* 2 (^ x 3)) (* -1 x))"))  # (+ (* (* (^ x 2) 3) 2) -1)

# Differentiate with respect to a different variable
print(differentiate("(+ x y)", "y"))  # "1"
print(differentiate("(* x y)", "y"))  # "x"

# Error handling
print(differentiate("(+ x"))     # Error: Missing closing parenthesis
print(differentiate("(/ x 0)"))  # Error: Cannot divide by zero 
```

## Implementation

- `tokenizer.py` converts input strings into a sequence of tokens.
  - `"(+ x 2)"` → `[LPAREN, OPERATOR(+), VARIABLE(x), NUMBER(2), RPAREN]`
- `parser.py` converts the token sequence into an [abstract syntax
  tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).
  - `[LPAREN, OPERATOR(+), VARIABLE(x), NUMBER(2), RPAREN]` → `ASTNode('OPERATOR', '+', [ASTNode('VARIABLE', 'x', []), ASTNode('NUMBER',
    '2', [])])`
- `differentiator.py` performs the core differentiation rules recursively on the
  AST.
- `simplifier.py` simplifies the AST generated by the differentiation function
  using rules like `1 + 2 + 3 + x` → `6 + x` and `1 * 2 * 3 * x` → `6 * x`.

## Testing

90%+ code coverage using pytest. Since differentiation has a bunch of
invariants, [Hypothesis](https://hypothesis.readthedocs.io/en/latest/) works
well for testing. From the linked documentation:

> Hypothesis is a Python library for creating unit tests which are simpler to write and more powerful when run, finding edge cases in your code you wouldn’t have thought to look for. It is stable, powerful and easy to add to any existing test suite.
>
> It works by letting you write tests that assert that something should be true for every case, not just the ones you happen to think of.

Here is an example of a test:

```python
@st.composite
def sexprs(draw, max_depth=2):
    """Generate random s-expressions with bounded depth."""
    if max_depth == 0:
        # Base case: return either a number or variable
        return draw(st.one_of(numbers, variables))

    # Recursive case: generate an operator expression
    operator = draw(st.sampled_from(["+", "*"]))
    if operator == "^":
        # For power, always generate number as exponent to avoid unsupported cases
        base = draw(sexprs(max_depth=max_depth - 1))
        exponent = draw(st.integers(min_value=0, max_value=5))
        return f"(^ {base} {exponent})"
    else:
        num_operands = draw(st.integers(min_value=2, max_value=5))
        operands = [draw(sexprs(max_depth=max_depth - 1)) for _ in range(num_operands)]
        return f"({operator} {' '.join(operands)})"

@given(sexprs(max_depth=2), sexprs(max_depth=2), variables)
def test_product_rule_property(expr1, expr2, var):
    """Property-based test for product rule: d/dx(f*g) = f'g + fg'"""
    product_expr = f"(* {expr1} {expr2})"
    product_derivative = differentiate(product_expr, var=var)

    # Compute parts separately
    d_expr1 = differentiate(expr1, var=var)
    d_expr2 = differentiate(expr2, var=var)

    # Build expected result: (+ (* f' g) (* f g'))
    expected = simplify(f"(+ (* {d_expr1} {expr2}) (* {expr1} {d_expr2}))")

    assert sexp_to_ast(product_derivative) == sexp_to_ast(expected)
```

We use a Hypothesis strategy to generate arbitrary s-expressions, then check to
see that a basic property of the product rule of derivatives always holds true.

## Development

GitHub Actions for continuous integration, running style checks, automated
tests, and code coverage reporting. 
