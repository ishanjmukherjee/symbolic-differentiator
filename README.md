# Symbolic differentiator

A Python library for symbolic differentiation of mathematical expressions. This
library takes
[Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language))-style
mathematical expressions and computes their derivatives with respect to a given
variable.

## Features

- Supports `+` and `*` with multiple operands.
- Supports `-`, `/` and `^` with two operands.
- Error handling and input validation.
- Property-based testing of invariants using [Hypothesis](https://hypothesis.readthedocs.io/en/latest/).

## Installation

1. Clone the repository:

```bash
git clone https://github.com/ishanjmukherjee/symbolic-differentiator.git
cd symbolic-differentiator
```

2. Install using `pip`:

```bash
pip install -e .
```

## Usage

The library uses Lisp-style symbolic expressions (s-expressions) for
mathematical formulas. The main difference is that we use [prefix](https://en.wikipedia.org/wiki/Polish_notation) instead of
the more common [infix](https://en.wikipedia.org/wiki/Infix_notation) operator notation. Here's how to represent some common expressions:

- `x + 2` → `(+ x 2)`
- `x * y` → `(* x y)`
- `(x + 1) * (y - 2)` → `(* (+ x 1) (- y 2))`
- `x^2` → `(^ x 2)`
- `(x + 1)/(y - 1)` → `(/ (+ x 1) (- y 1))`

The main advantage of this format is that it makes operator precedence unambiguous.

The main function `differentiate()` takes an expression string and a variable name
(defaults to "`x`") and returns the derivative as a simplified s-expression
string.

## Error handling

- Invalid syntax: Mismatched parentheses, invalid operators
- Invalid variable names: Empty strings, whitespace, invalid characters
- Mathematical errors: Division by zero, invalid exponents
- Unsupported operations: undefined operators (like trig and log for now)

## Examples

A more extensive demonstration of usage is in `demo.py`.

```python
from symbolic_diff import differentiate

# Basic examples
print(differentiate("x"))        # "1"
print(differentiate("(+ x 5)"))  # "1"
print(differentiate("(* x x)"))  # "(+ x x)"
print(differentiate("(^ x 2)"))  # "(* 2 x)"

# More complex examples
print(differentiate("(* (+ x 1) (- x 2))"))         # (+ (+ x -2) (+ x 1))
print(differentiate("(+ (* 2 (^ x 3)) (* -1 x))"))  # (+ (* (* (^ x 2) 3) 2) -1)

# Differentiate with respect to a different variable
print(differentiate("(+ x y)", "y"))  # "1"
print(differentiate("(* x y)", "y"))  # "x"

# Error handling
print(differentiate("(+ x"))     # Error: Missing closing parenthesis
print(differentiate("(/ x 0)"))  # Error: Cannot divide by zero 
```

## Implementation

- `tokenizer.py` converts input strings into a sequence of tokens.
  - `"(+ x 2)"` → `[LPAREN, OPERATOR(+), VARIABLE(x), NUMBER(2), RPAREN]`
- `parser.py` converts the token sequence into an [abstract syntax
  tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).
  - `[LPAREN, OPERATOR(+), VARIABLE(x), NUMBER(2), RPAREN]` → `ASTNode('OPERATOR', '+', [ASTNode('VARIABLE', 'x', []), ASTNode('NUMBER',
    '2', [])])`
- `differentiator.py` performs the core differentiation rules recursively on the
  AST.
- `simplifier.py` simplifies the AST generated by the differentiation function
  using rules like `1 + 2 + 3 + x` → `6 + x` and `1 * 2 * 3 * x` → `6 * x`.